\section{Rappels sur le noyau fonctionnel}
%slide 3
\begin{frame}
  \begin{center}
    \frametitle{la programmation fonctionnelle}
  Le noyau fonctionnel, la sup, le bon temps, toussa toussa....
  \end{center}
\end{frame}
%slide 4

\subsection{Les composants de bases}

\begin{frame}[fragile]
  \frametitle{le noyaux fonctionnel}
  \framesubtitle{Les types numériques}
   \begin{minipage}[t]{5cm}
    les ints/entiers : 
    \begin{lstlisting}
    42;;
    - : int  = 42
    \end{lstlisting}
   \end{minipage}
   \begin{minipage}[t]{5cm}
    les floats/flottants:w :
    \begin{lstlisting}
    4.2;;
    - : float = 4.2
    \end{lstlisting}
   \end{minipage}
   \vspace{0.5cm}
    et leurs utilisations :\\
   \begin{minipage}[t]{5cm}
     \begin{lstlisting}
    4 * 10 + 2;;
      - : int = 42
     \end{lstlisting}
   \end{minipage}
   \begin{minipage}[t]{5cm}
     \begin{lstlisting}
    41.5 +. 0.5;;
     - : float = 42
     \end{lstlisting}
   \end{minipage}
\end{frame}
%slide 5
  \subsection{les chars et chaines de chars}
\begin{frame}[fragile]
    \frametitle{le noyaux fonctionnel}
    \framesubtitle{caractères et chaines de caractère}
    Les caractères sont bien pratique si l'on veuille faire un interfaçage avec l'utilisateur ou d'autre ... truc (*caugh* ocr *caugh*)\\
    \begin{minipage}[t]{10cm}
      \begin{lstlisting}
      "coucou je suis une chaine";;
      - : string = "coucou je suis une chaine"
      \end{lstlisting}
    \end{minipage}
    \begin{minipage}[t]{5cm}
      \begin{lstlisting}
      '4';;
      - : char = '4'
      \end{lstlisting}
    \end{minipage}
\end{frame}
%slide 6
  \subsection{les boolèens}
\begin{frame}
    \frametitle{le noyaux fonctionnel}
    \framesubtitle{les boolèens}
      La logique booléenne est composée de 2 "termes" true et false, ils s'utilisent avec les operateurs suivants :
      \begin{center}
      \begin{minipage}[t]{7cm}
	  \begin{itemize}
	    \item "not" : négation
	    \item "\&\&" : et sequentiel
	    \item "||" : ou sequentiel
	    \item "\&" : synonyme pour "\&\&"
	    \item "or" : synonyme pour "||"
	  \end{itemize}
	\end{minipage}
      \end{center}
	\begin{minipage}[t]{5cm}
	  \begin{itemize}
	    \item "=" : egalité structurelle
	    \item "==" : egalité physique
	    \item "<>" : negation de "="
	    \item "!=" : negation de "=="
	  \end{itemize}
	\end{minipage}
	\begin{minipage}[t]{5cm}
	  \begin{itemize}
	    \item "<" : inferieur 
	    \item ">" : superieur
	    \item "<=" : inferieur égale
	    \item ">=" : superieur égale
	  \end{itemize}
	\end{minipage}
\end{frame}
%slide 7
    \subsection{le controle conditionnel}
\begin{frame}
      \frametitle{le noyaux fonctionnel}
      \framesubtitle{le controle conditionnel}
      \begin{center}
	if a then b (else c);;
  \end{center}
\end{frame}
%slide 8
    \subsection{les declarations}
\begin{frame}[fragile]
      \frametitle{le noyaux fonctionnel}
      \framesubtitle{les declarations}
      il existe deux types de declaration :
     \begin{minipage}[t]{5cm}
	les globales :\\
	\begin{lstlisting}
	let a = "42";;
	val a : string = "42"
	\end{lstlisting}
	avec repetition :
	\begin{lstlisting}
	let a = 2
	and b = 3
	and c = 4;;
	val a : int = 2
	val b : int = 3
	val c : int = 4
	\end{lstlisting}
      \end{minipage}
      \begin{minipage}[t]{5cm}
	les locales :\\
	\begin{lstlisting}
	let a = 2 in a + 1;;
	- : int = 3
	\end{lstlisting}
	avec repetition :
	\begin{lstlisting}
	let a = 2
	and b = 3
	and c = 4 in
	a + b + c;;
	- : int = 9
	\end{lstlisting}
      \end{minipage}
\end{frame}
%slide 9
    \subsection{Les fonctions}
\begin{frame}[fragile]
      \frametitle{Le noyaux fonctionnel}
      \framesubtitle{les fonctions}
      \begin{minipage}[t]{7cm}
	\begin{center}
	\begin{itemize}
    \begin{lstlisting}
     function x -> x + 1;;
     -: int -> int = <fun>
    \end{lstlisting}
    \begin{lstlisting}
     function x -> function y -> x + y;;
     - : int -> int -> int = <fun>
    \end{lstlisting}
    \begin{lstlisting}
     function (x , y) -> x * y;;
     - : int * int -> int = <fun>
    \end{lstlisting}
   \begin{lstlisting}
     fun x y -> x + y;;
     - : int -> int -> int = <fun>
    \end{lstlisting}
  \end{itemize}
  \end{center}
  \end{minipage}
\end{frame}

%slide 10
\subsection{Declaration de fonction}
\begin{frame}[fragile]
  \frametitle{Le noyaux fonctionnel}
  \framesubtitle{Declaration de fonctions}
    \begin{lstlisting}
	let nom p1 ... pn = expr
    \end{lstlisting}
	\begin{center}
	  \begin{rotate}{90}
     $\Leftrightarrow$
   \end{rotate}
\end{center}
\begin{lstlisting}
let nom = function p1 ->-> function pn -> expr
  \end{lstlisting}
  \vspace{1cm}
  \begin{lstlisting}
  let add x y = x + y;;
  val add : int -> int -> int = <fun>
  \end{lstlisting}
  declaration de fonction recursive 
  \begin{lstlisting}
  let rec facto x = if x = 0 then 1 else x * facto(x-1);;
  val facto : int -> int = <fun>
  \end{lstlisting}
\end{frame}
%slide 11
\subsection{l'ordre superieur}
\begin{frame}[fragile]
  \frametitle{le noyaux fonctionnel}
  \framesubtitle{l'ordre superieur}
  et si on faisait des fonctions de fonctions ? 
 \begin{lstlisting}
  let sup f a = f a;;
  val sup : ('a -> 'b) -> 'a -> 'b = <fun>
 \end{lstlisting}
 ce qui nous permet de voir le polymorphysme representé par les 'a et 'b qui definissent tout les types.
\end{frame}

      \subsection{le filtrage de motif}
\begin{frame}[fragile]
  \frametitle{le noyaux fonctionnel}
  \framesubtitle{le filtrage de motif}
  \begin{minipage}[t]{5cm}
    \begin{lstlisting}
match expr with
 |p1 -> expr1
 .
 .
 |p2 -> expr2
 \end{lstlisting}
 \end{minipage}
 \begin{minipage}[t]{8cm}
   \begin{lstlisting}
   let forty_two  = function
     42 -> true
    |_ -> false;;
    val forty_two : int -> bool = <fun>
   \end{lstlisting} 
 \end{minipage}
\end{frame}
\begin{frame}[fragile]
  \frametitle{le noyaux fonctionnel}
  \framesubtitle{le filtrage de motif : justification}
remember, remember ...
\begin{lstlisting}
let f = function x -> x + 1 
\end{lstlisting}
\begin{center}
\begin{rotate}{90}
$\Leftrightarrow$
\end{rotate}
\end{center}
\begin{lstlisting}
let f = function 
 x -> x + 1;;
 \end{lstlisting}
  il s'agissait de filtrage dès le debut ! on justifie ainsi la syntaxe du pattern matching, 
  on appelle ça un filtrage de paramètre ici on filtre le paramètre de f avec x, soit n'importe quoi.
\end{frame}
\begin{frame}[fragile]
  \frametitle{le noyau fonctionnel}
  \framesubtitle{le filtrage de motif : as et when}
  \begin{itemize}
  \begin{minipage}[t]{5cm}
  \item
    as :
    \begin{lstlisting}
	let rec fibo = function 
 	0|1 as n -> n 
 	|x -> fibo(x - 1) + fibo(x - 2);; 
	val fibo : int -> int = <fun>
    \end{lstlisting}
  \end{minipage}
  \begin{minipage}[t]{5cm}
  \item
    when :
    \begin{lstlisting}
	let is_inf = function 
  	x when x < 42 -> true
 	|_ -> false;;
	val is_inf : int -> int = <fun>
    \end{lstlisting}
  \end{minipage}
  \end{itemize}
\end{frame}
      \subsection{Les types}
\begin{frame}[fragile]
	\frametitle{le noyaux fonctionnel}
	\framesubtitle{le type somme et le type récuresif}
	le type somme :
	\begin{lstlisting}
type nom =
        |Nom1 
        |Nom2 of t0 
        |Nom3 of t1 * t2 *.... * tn 
	\end{lstlisting}
	le type récuresif :
	\begin{lstlisting}
type nom =
        |Nom1
        |Nom2 of nom
        |Nom3 of t1 * t2 *.... * tn
         \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{le noyaux fonctionnel}
  \framesubtitle{le type paramétrés}
  le type paramétrés :
  \begin{lstlisting}
type nom =
         |Nom 1
         |Nom 2 of t0
         |Nom3 of ('a -> 'b)
  \end{lstlisting}
  \begin{lstlisting}
type nom = 
         |Nom 1 
         |Nom 2 of t0
         |Nom 3 of 'a 
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{le noyaux fonctionnel}
  \framesubtitle{les exceptions}
  \begin{lstlisting}
exception Nom;;
exception Nom of int;;
  \end{lstlisting}
pour lever un exception : 
\begin{lstlisting}
raise ;;
- : exn -> 'a = <fun>
\end{lstlisting}
\begin{lstlisting}
try exp with 
|p1 -> exp1
|p2 -> exp2
.
.
.
|p3 -> exp3
\end{lstlisting}

\end{frame}
