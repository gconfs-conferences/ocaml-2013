\section{Rappels des bases d'OCaml}
\begin{frame}
  \begin{center}
	\huge
	La base, la sup, etc... et deux trois autres choses !
  \end{center}
\end{frame}

\subsection{Les données de base} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
	\frametitle{Les types élémentaires}
	\begin{itemize}
		\item Les entiers : 42\\
			~~4 * 10 + 2
		\item Les flotants : 4.2\\
			~~41.5 +. 0.5
		\item Les caractères : '*'\\
		\item Les chaines de caratères : "abcd"\\
			~~"The " \^~"meaning of " \^~"life"
			\item Les n-uplet : ( 1, 2, 3, 4 )
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Les listes}
	\begin{itemize}

	\item Liste vide
		\begin{lstlisting}
		[]
		\end{lstlisting}

	\item Opérateur de construction
		\begin{lstlisting}
		a :: []
		\end{lstlisting}

	\item Concatenation (à éviter)
		\begin{lstlisting}
		liste1 @ liste2
		\end{lstlisting}
		
	\item \textit{length, ith element, rev}...\\
	  Voir la doc du module List.

	\end{itemize}
\end{frame}

\subsection{Déclaration et fonctions} %%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
      \frametitle{Les declarations}
      Il existe deux types de declaration :
     \begin{minipage}[t]{5cm}
	Les globales :\\
	\begin{lstlisting}
	let a = "42";;
	val a : string = "42"
	\end{lstlisting}
	avec repetition :
	\begin{lstlisting}
	let a = 2
	and b = 3
	and c = 4;;
	val a : int = 2
	val b : int = 3
	val c : int = 4
	\end{lstlisting}
      \end{minipage}
      \begin{minipage}[t]{5cm}
	les locales :\\
	\begin{lstlisting}
	let a = 2 in a + 1;;
	- : int = 3
	\end{lstlisting}
	avec repetition :
	\begin{lstlisting}
	let a = 2
	and b = 3
	and c = 4 in
	a + b + c;;
	- : int = 9
	\end{lstlisting}
      \end{minipage}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Les fonctions}
	\begin{center}
		\begin{minipage}{10cm}
				\begin{lstlisting}
     function x -> x + 1;;
     -: int -> int = <fun>
				\end{lstlisting}
				\begin{lstlisting}
     function x -> function y -> x + y;;
     - : int -> int -> int = <fun>
				\end{lstlisting}
				\begin{lstlisting}
     function (x , y) -> x * y;;
     - : int * int -> int = <fun>
				\end{lstlisting}
				\begin{lstlisting}
     fun x y -> x + y;;
     - : int -> int -> int = <fun>
				\end{lstlisting}
		\end{minipage}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Declaration de fonctions}
    \begin{lstlisting}
	let nom p1 pn = expr
    \end{lstlisting}
\begin{lstlisting}
let nom = 
  function p1 -> function pn -> expr
  \end{lstlisting}
  \vspace{0.4cm}
  \begin{lstlisting}
let add x y = 
  x + y;;
val add : 
  int -> int -> int = <fun>
  \end{lstlisting}
  Déclaration de fonction recursive 
  \begin{lstlisting}
  let rec facto x = 
    if x = 0 then 1 else x * facto(x-1);;
  val facto : int -> int = <fun>
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{L'ordre superieur}
  Et si on faisait des fonctions de fonctions ? 
 \begin{lstlisting}
  let sup f a = f a;;
  val sup : ('a -> 'b) -> 'a -> 'b = <fun>
 \end{lstlisting}
 Ce qui nous permet de voir le polymorphysme representé par les 'a et 'b qui definissent tout les types.
\end{frame}

\begin{frame}[fragile]
	\frametitle{Les paramètres optionnels}
	\begin{itemize}	

	\item 	\begin{lstlisting}
		let incr ?pas:(x = 1) r = r + x
		\end{lstlisting}

	\item 	\begin{lstlisting}
		incr ~pas:10 32
		\end{lstlisting}

\end{itemize}
\end{frame}

\subsection{Faire des choix} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
	\frametitle{Le contrôle conditionnel}
	\begin{center}
		\begin{minipage}{6cm}
			\lstset{basicstyle=\Large}
			\begin{lstlisting}
      if a
        then b 
        else c

bool -> 'a -> 'a -> 'a
			\end{lstlisting}
		\end{minipage}\\
		\begin{minipage}{4cm}
			\lstset{basicstyle=\scriptsize}
			\begin{lstlisting}
if a=42
  then 
    print_string "42!" 
  (else ())
			\end{lstlisting}
		\end{minipage}
	\end{center}
\end{frame}

\begin{frame}
    \frametitle{Les tests boolèen}
	\begin{center}
		\begin{center}
			\begin{minipage}{4cm}
				\begin{itemize}
					\item "not" : négation
					\item "\&\&" : et logique
					\item "||" : ou logique
				\end{itemize}
			\end{minipage}
			\begin{minipage}{5cm}
				\begin{itemize}
					\item "=" : egalité structurelle
					\item "<>" : negation de "="
				\end{itemize}
			\end{minipage}
		\end{center}\vspace{0.2cm}
		\begin{minipage}{4.5cm}
			\begin{itemize}
				\item "<" : inferieur 
				\item ">" : superieur
				\item "<=" : inferieur égale
				\item ">=" : superieur égale
			\end{itemize}
		\end{minipage}
	\end{center}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Le filtrage de motif}
	\begin{center}
	\begin{minipage}{4cm}
		\begin{lstlisting}
match expr with
   m1 -> expr1
 | m2 -> expr2
 | pn -> exprn
		\end{lstlisting}
	\end{minipage}
	\begin{minipage}{5cm}
		\begin{lstlisting}
match i with
   0 -> expr1
 | 5 | 12 -> expr2
 | n -> expr4
		\end{lstlisting}
	\end{minipage}
	
	\begin{minipage}{3cm}
		\begin{lstlisting}
function
    42 -> true
  | _ -> false
		\end{lstlisting} 
	\end{minipage}
	\end{center}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Le filtrage de motif : récursion et listes}
		\begin{lstlisting}
let rec printStrList l = match l with
    [] -> print_string "\n"
  | e::[] -> print_string e ^ "\n"
  | e::q -> 
    print_string e ^ ", ";
    printStrList q
		\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Le filtrage de motif : as et when}
  \begin{itemize}
  \begin{minipage}[t]{5cm}
  \item
    as :
    \begin{lstlisting}
	let rec fibo = function 
 	  0 | 1 as n -> n 
 	| x -> fibo(x - 1) + fibo(x - 2);; 
    \end{lstlisting}
  \end{minipage}
  \begin{minipage}[t]{5cm}
  \item
    when :
    \begin{lstlisting}
  let is_inf = function 
      x when x < 42 -> true
 	  | _ -> false;;
    \end{lstlisting}
  \end{minipage}
  \end{itemize}
\end{frame}

\subsection{Les types} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
	\frametitle{Créer un type}
	\textbf{types simples}
	\begin{lstlisting}
  type name = typedef

  type point = int * int
  type stringLabeledIntList = 
    string * (int list)
  type funIntList = (int list) -> int
	\end{lstlisting}
	\textbf{types paramétrés}
	\lstset{basicstyle=\scriptsize}
	\begin{lstlisting}
  type ('nameTypeParameter1,'nameTypeParameterN) name = 
    typedef
    
  type ('label,'valType) labeledList =
    'label * ('valType list) 
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Le type somme}
	\begin{lstlisting}
  type name =
    | Constructor1 
    | Constructor2 of t0 
    | Constructor3 of t1 * t2 * tn 
	\end{lstlisting}
	
	\begin{center}
		\begin{minipage}{4.3cm}
			\lstset{basicstyle=\scriptsize}
			\begin{lstlisting}
type ('element) myList =
  | Void
  | Element of 
    'element * 
    ('element myList)
			\end{lstlisting}
		\end{minipage}\\
		\begin{minipage}{7.3cm}
			\lstset{basicstyle=\scriptsize}
			\begin{lstlisting}
let rec printStrMyList l = match l with
    Void -> print_string "\n"
  | Element (e,Void) -> 
    print_string e ^ "\n"
  | Element (e,q) -> 
    print_string e ^ ", ";
    printStrList q
			\end{lstlisting}
		\end{minipage}
	\end{center}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Les exceptions}
	\begin{lstlisting}
 exception Help
 exception HelpNbErr of int
	\end{lstlisting}
	\textbf{Pour lever une exception :}
	\begin{lstlisting}
  raise Help
  raise (HelpNbErr 451)
  
  invalid_arg "element parameter"
  failwith "uninitialized Graphics"
	\end{lstlisting}
	\textbf{Pour traiter une exception :}
	\begin{center}
		\begin{minipage}{4.2cm}
			\lstset{basicstyle=\scriptsize}
			\begin{lstlisting}
try expr with 
| Exc1 -> expr1
| Exc2 (v1,v2) -> expr2
| Excn -> exprn
			\end{lstlisting}
		\end{minipage}
		\begin{minipage}{5cm}
			\lstset{basicstyle=\scriptsize}
			\begin{lstlisting}
try expr with 
| MyExc -> print_string "lol"
| Invalid_argument n -> 
  print_string ("InvArg:"^n)
| Failure -> exit (-1)
			\end{lstlisting}
		\end{minipage}
	\end{center}
\end{frame}
