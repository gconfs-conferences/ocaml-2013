\section{Rappels des bases d'OCaml}
\begin{frame}
  \begin{center}
	\huge
	La base, la sup, etc... et deux trois autres nouveautés !
  \end{center}
\end{frame}

\subsection{Les données de base} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
	\frametitle{Les types élémentaires}
	\begin{itemize}
		\item Les entiers : 42\\
			~~4 * 10 + 2
		\item Les flottants : 4.2\\
			~~41.5 +. 0.5
		\item Les caractères : 'c'\\
		\item Les chaines de caractères : "abcd"\\
			~~"The " \^~"meaning of " \^~"life"
			\item Les n-uplets : ( 1, 2, 3, 4 )
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Les listes}
	\framesubtitle{Mais qu'est-ce que c'est ?}
	\begin{itemize}

	\item Liste vide:
		\begin{lstlisting}
		[]
		\end{lstlisting}

	\item Opérateur de construction:
		\begin{lstlisting}
		a :: []
		\end{lstlisting}

	\item Concaténation (à éviter):
		\begin{lstlisting}
		liste1 @ liste2
		\end{lstlisting}

	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Les listes}
	\framesubtitle{Quelques fonctionnalités du module List}
	\begin{itemize}
	
	\item List.length : retourne la longueur d'une liste.	
	
	\item List.append : equivalent de @ mais optimisé.
	
	\item List.rev : inverse la liste passée en paramètre.
	
	\item List.iter et iter2 : Renvoi l'application d'une fonction f à chacun des éléments de la liste.

	\item List.map et map2 : Renvoi une liste à produit par l'application d'une fonction f à chacun des éléments de la liste.

	\end{itemize}
\end{frame}


\subsection{Déclaration et fonctions} %%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
      \frametitle{Les déclarations}
      Il existe deux types de déclaration :
	\begin{columns}[t]
		\begin{column}{5cm}
		\begin{block}{Les globales :}
		\begin{lstlisting}
	let a = "42";;
	val a : string = "42"
	\end{lstlisting}
	avec répétition :
	\begin{lstlisting}
	let a = 2
	and b = 3
	and c = 4;;
	val a : int = 2
	val b : int = 3
	val c : int = 4
		\end{lstlisting}
		\end{block}
		\end{column}
      		\begin{column}{5cm}
		\begin{block}{Les locales:}
		\begin{lstlisting}
	let a = 2 in a + 1;;
	- : int = 3
	\end{lstlisting}
	avec répétition :
	\begin{lstlisting}
	let a = 2
	and b = 3
	and c = 4 in
	a + b + c;;
	- : int = 9
		\end{lstlisting}
		\end{block}
      		\end{column}
	\end{columns}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Les fonctions}
	\framesubtitle{Représentation}
	\begin{center}
		\begin{minipage}{10cm}
				\begin{lstlisting}
     function x -> x + 1;;
     -: int -> int = <fun>
				\end{lstlisting}
				\begin{lstlisting}
     function x -> function y -> x + y;;
     - : int -> int -> int = <fun>
				\end{lstlisting}
				\begin{lstlisting}
     function (x , y) -> x * y;;
     - : int * int -> int = <fun>
				\end{lstlisting}
				\begin{lstlisting}
     fun x y -> x + y;;
     - : int -> int -> int = <fun>
				\end{lstlisting}
		\end{minipage}
  \end{center}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Les fonctions}
  	\framesubtitle{Déclaration}
    	\begin{lstlisting}
	let name p1 pn = expr
    	\end{lstlisting}
	\begin{lstlisting}
let name = 
  function p1 -> function pn -> expr
  	\end{lstlisting}
  	\vspace{0.4cm}
  	\begin{lstlisting}
let add x y = 
  x + y;;
val add : 
  int -> int -> int = <fun>
  	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Les fonctions}
	\framesubtitle{Déclaration récursive}
	\begin{block}{Déclaration de fonction recursive} 
	  \begin{lstlisting}
	  let rec facto x = 
	  	if x = 0 then 1 else x * facto(x-1);;
	  val facto : int -> int = <fun>
	  \end{lstlisting}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Les fonctions}
  	\framesubtitle{L'ordre superieur}
  	Et si nous faisions des fonctions de fonctions ? 
 	\begin{lstlisting}
  let sup f a = f a;;
  val sup : ('a -> 'b) -> 'a -> 'b = <fun>
 	\end{lstlisting}
	Nous retrouvons ici le type polymorphe representé par\\
	les 'a et 'b qui rassemblent tout les types.
\end{frame}

\begin{frame}[fragile]
	\frametitle{Les fonctions}
	\framesubtitle{Les paramètres optionnels}	

	 	\begin{block}{Déclaration}
		\begin{lstlisting}
		let incr ?pas:(x = 1) r = r + x
		\end{lstlisting}
		\end{block}

	 	\begin{block}{Utilisation}
		\begin{lstlisting}
		incr ~pas:10 32
		\end{lstlisting}
		\end{block}

\end{frame}

\subsection{Faire des choix} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
	\frametitle{Le contrôle conditionnel}
	\begin{block}{La structure}
	\begin{lstlisting}
	  let f a b c = 
	    if a
	     then b 
	     else c
	  bool -> 'a -> 'a -> 'a
	\end{lstlisting}
	\end{block}
	\begin{block}{Exemple}
	\begin{lstlisting}
	  if a=42
  	  then 
    	  print_string "42!" 
  	  (else ())
	\end{lstlisting}
	\end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Les tests booléens}
	\begin{columns}
		\begin{column}{5cm}
			\begin{itemize}
				\item "not" : négation
				\item "\&\&" : et logique
				\item "||" : ou logique
				\item "=" : egalité structurelle
				\item "<>" : negation de "="
			\end{itemize}
		\end{column}
		\begin{column}{5cm}
			\begin{itemize}
				\item "<" : inferieur 
				\item ">" : superieur
				\item "<=" : inferieur égale
				\item ">=" : superieur égale
			\end{itemize}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Le filtrage de motif}
	\framesubtitle{Généralités}
	\begin{block}{Expression générale}
		\begin{lstlisting}
  match expr with
     m1 -> expr1
   | m2 -> expr2
   | pn -> exprn
		\end{lstlisting}
	\end{block}
	\begin{block}{Exemples}
		\begin{columns}
		\begin{column}{5cm}
		\begin{lstlisting}
  match i with
     0 -> expr1
   | 5 | 12 -> expr2
   | n -> exprn
		\end{lstlisting}
		\end{column}
		\begin{column}{5cm}
		\begin{lstlisting}
  function
      42 -> true
    | _ -> false
		\end{lstlisting} 
		\end{column}
	\end{columns}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Le filtrage dei motif}
	\framesubtitle{Récursion et listes}
		\begin{lstlisting}
  let rec printStrList l = match l with
      [] -> print_string "\n"
    | e::[] -> print_string (e ^ "\n")
    | e::q -> 
      print_string(e ^ ", ");
      printStrList q
		\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  	\frametitle{Le filtrage de motif}
	\framesubtitle{as et when}
  	\begin{block}{as:}
    	\begin{lstlisting}
	  let rec fibo = function 
 	    0 | 1 as n -> n 
 	  | x -> fibo(x - 1) + fibo(x - 2);; 
    	\end{lstlisting}
  	\end{block}
  	\begin{block}{when:}
    	\begin{lstlisting}
  let is_inf = function 
        x when x < 42 -> true
    	| _ -> false;;
    	\end{lstlisting}
  	\end{block}
\end{frame}

\subsection{Les types} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
	\frametitle{Créer un type}
	\framesubtitle{Types simples}
	\begin{lstlisting}
  type name = typeToDefine

  type point = int * int

  type stringLabeledIntList = 
    string * (int list)

  type funIntList = (int list) -> int
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Créer un type}
	\framesubtitle{Types paramétrés}
	\begin{lstlisting}
  type ('nameTypeParameter1,
 	     'nameTypeParameterN) 
   	    name = 
         typeToDefine
    
  type ('label,'valType) labeledList =
    'label * ('valType list) 
	\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
	\frametitle{Créer un type}
	\framesubtitle{Le type somme}
	\begin{lstlisting}
  type name =
    | Constructor1 
    | Constructor2 of t0 
    | Constructor3 of t1 * t2 * tn 
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Créer un type}
	\framesubtitle{Le type somme: Application}
			\begin{lstlisting}
type ('element) myList =
  | Void
  | Element of 
      'element * 
      ('element myList)
			\end{lstlisting}

			\begin{lstlisting}
let rec printStrMyList l = match l with
    Void -> print_string "\n"
  | Element (e,Void) -> 
      print_string e ^ "\n"
  | Element (e,q) -> 
      print_string e ^ ", ";
      printStrList q
			\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Les exceptions}
	\begin{lstlisting}
 exception Help
 exception HelpNbErr of int
	\end{lstlisting}
	\textbf{Pour lever une exception :}
	\begin{lstlisting}
  raise Help
  raise (HelpNbErr 451)
  
  invalid_arg "element parameter"
  failwith "uninitialized Graphics"
	\end{lstlisting}
	\textbf{Pour traiter une exception :}
	\begin{center}
		\begin{minipage}{4.2cm}
			\lstset{basicstyle=\scriptsize}
			\begin{lstlisting}
try expr with 
| Exc1 -> expr1
| Exc2 (v1,v2) -> expr2
| Excn -> exprn
			\end{lstlisting}
		\end{minipage}
		\begin{minipage}{5cm}
			\lstset{basicstyle=\scriptsize}
			\begin{lstlisting}
try expr with 
| MyExc -> print_string "lol"
| Invalid_argument n -> 
    print_string ("InvArg:"^n)
| Failure -> exit (-1)
			\end{lstlisting}
		\end{minipage}
	\end{center}
\end{frame}
