\section{Rappels des bases d'OCaml}
\begin{frame}
  \begin{center}
	\huge
	La base, la sup, etc... et deux trois autres choses !
  \end{center}
\end{frame}

\subsection{Les données de base} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
	\frametitle{Les types élémentaires}
	\begin{itemize}
		\item Les entiers : 42\\
			~~4 * 10 + 2
		\item Les flotants : 4.2\\
			~~41.5 +. 0.5
		\item Les caractères : '*'\\
		\item Les chaines de caratères : "abcd"\\
			~~"The " \^~"meaning of " \^~"life"
			\item Les n-uplet : ( 1, 2, 3, 4 )
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Les listes}
	\begin{itemize}

	\item Liste vide
		\begin{lstlisting}
		[]
		\end{lstlisting}

	\item Opérateur de construction
		\begin{lstlisting}
		a :: []
		\end{lstlisting}

	\item Concatenation (à éviter)
		\begin{lstlisting}
		liste1 @ liste2
		\end{lstlisting}
		
	\item \textit{length, ith element, rev}...\\
	  Voir la doc du module List.

	\end{itemize}
\end{frame}

\subsection{Les fonctions} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
      \frametitle{Le fonctionnel}
      \framesubtitle{Les declarations}
      Il existe deux types de declaration :
     \begin{minipage}[t]{5cm}
	Les globales :\\
	\begin{lstlisting}
	let a = "42";;
	val a : string = "42"
	\end{lstlisting}
	avec repetition :
	\begin{lstlisting}
	let a = 2
	and b = 3
	and c = 4;;
	val a : int = 2
	val b : int = 3
	val c : int = 4
	\end{lstlisting}
      \end{minipage}
      \begin{minipage}[t]{5cm}
	les locales :\\
	\begin{lstlisting}
	let a = 2 in a + 1;;
	- : int = 3
	\end{lstlisting}
	avec repetition :
	\begin{lstlisting}
	let a = 2
	and b = 3
	and c = 4 in
	a + b + c;;
	- : int = 9
	\end{lstlisting}
      \end{minipage}
\end{frame}

\begin{frame}[fragile]
      \frametitle{Le fonctionnel}
      \framesubtitle{Les fonctions}
      \begin{minipage}[t]{7cm}
	\begin{center}
	\begin{itemize}
    \begin{lstlisting}
     function x -> x + 1;;
     -: int -> int = <fun>
    \end{lstlisting}
    \begin{lstlisting}
     function x -> function y -> x + y;;
     - : int -> int -> int = <fun>
    \end{lstlisting}
    \begin{lstlisting}
     function (x , y) -> x * y;;
     - : int * int -> int = <fun>
    \end{lstlisting}
   \begin{lstlisting}
     fun x y -> x + y;;
     - : int -> int -> int = <fun>
    \end{lstlisting}
  \end{itemize}
  \end{center}
  \end{minipage}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Le fonctionnel}
  \framesubtitle{Declaration de fonctions}
    \begin{lstlisting}
	let nom p1 ... pn = expr
    \end{lstlisting}
	\begin{center}
	  \begin{rotate}{90}
     $\Leftrightarrow$
   \end{rotate}
\end{center}
\begin{lstlisting}
let nom = function p1 ->-> function pn -> expr
  \end{lstlisting}
  \vspace{1cm}
  \begin{lstlisting}
  let add x y = x + y;;
  val add : int -> int -> int = <fun>
  \end{lstlisting}
  Déclaration de fonction recursive 
  \begin{lstlisting}
  let rec facto x = if x = 0 then 1 else x * facto(x-1);;
  val facto : int -> int = <fun>
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Le fonctionnel}
  \framesubtitle{L'ordre superieur}
  Et si on faisait des fonctions de fonctions ? 
 \begin{lstlisting}
  let sup f a = f a;;
  val sup : ('a -> 'b) -> 'a -> 'b = <fun>
 \end{lstlisting}
 Ce qui nous permet de voir le polymorphysme representé par les 'a et 'b qui definissent tout les types.
\end{frame}

\begin{frame}[fragile]
	\frametitle{Le fonctionnel}
	\framesubtitle{Les paramètres optionnels}
	\begin{itemize}	

	\item 	\begin{lstlisting}
		let incr ?pas:(x = 1) r = r + x
		\end{lstlisting}

	\item 	\begin{lstlisting}
		incr ~pas:10 32
		\end{lstlisting}

\end{itemize}
\end{frame}

\subsection{Faire des choix} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
	\frametitle{Le contrôle conditionnel}
	\begin{center}
		\begin{minipage}{6cm}
			\lstset{basicstyle=\Large}
			\begin{lstlisting}
      if a
        then b 
        else c

bool -> 'a -> 'a -> 'a
			\end{lstlisting}
		\end{minipage}\\
		\begin{minipage}{4cm}
			\lstset{basicstyle=\scriptsize}
			\begin{lstlisting}
if a=42
  then 
    print_string "42!" 
  (else ())
			\end{lstlisting}
		\end{minipage}
	\end{center}
\end{frame}

\begin{frame}
    \frametitle{Les tests boolèen}
	\begin{center}
		\begin{center}
			\begin{minipage}{4cm}
				\begin{itemize}
					\item "not" : négation
					\item "\&\&" : et logique
					\item "||" : ou logique
				\end{itemize}
			\end{minipage}
			\begin{minipage}{5cm}
				\begin{itemize}
					\item "=" : egalité structurelle
					\item "<>" : negation de "="
				\end{itemize}
			\end{minipage}
		\end{center}\vspace{0.2cm}
		\begin{minipage}{4.5cm}
			\begin{itemize}
				\item "<" : inferieur 
				\item ">" : superieur
				\item "<=" : inferieur égale
				\item ">=" : superieur égale
			\end{itemize}
		\end{minipage}
	\end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Le fonctionnel}
  \framesubtitle{Le filtrage de motif}
  \begin{minipage}[t]{5cm}
    \begin{lstlisting}
match expr with
 |p1 -> expr1
 .
 .
 |pn -> exprn
 \end{lstlisting}
 \end{minipage}
 \begin{minipage}[t]{8cm}
   \begin{lstlisting}
   let forty_two  = function
     42 -> true
    |_ -> false;;
    val forty_two : int -> bool = <fun>
   \end{lstlisting} 
 \end{minipage}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Le fonctionnel}
  \framesubtitle{Le filtrage de motif : justification}
remember, remember ...
\begin{lstlisting}
let f = function x -> x + 1 
\end{lstlisting}
\begin{center}
\begin{rotate}{90}
$\Leftrightarrow$
\end{rotate}
\end{center}
\begin{lstlisting}
let f = function 
 x -> x + 1;;
 \end{lstlisting}
  il s'agissait de filtrage dès le debut ! on justifie ainsi la syntaxe du pattern matching, 
  on appelle ça un filtrage de paramètre ici on filtre le paramètre de f avec x, soit n'importe quoi.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Le fonctionnel}
  \framesubtitle{Le filtrage de motif : as et when}
  \begin{itemize}
  \begin{minipage}[t]{5cm}
  \item
    as :
    \begin{lstlisting}
	let rec fibo = function 
 	0|1 as n -> n 
 	|x -> fibo(x - 1) + fibo(x - 2);; 
	val fibo : int -> int = <fun>
    \end{lstlisting}
  \end{minipage}
  \begin{minipage}[t]{5cm}
  \item
    when :
    \begin{lstlisting}
	let is_inf = function 
  	x when x < 42 -> true
 	|_ -> false;;
	val is_inf : int -> int = <fun>
    \end{lstlisting}
  \end{minipage}
  \end{itemize}
\end{frame}

\subsection{Les types} 
\begin{frame}[fragile]
	\frametitle{Le fonctionnel}
	\framesubtitle{Le type somme et le type récuresif}
	le type somme :
	\begin{lstlisting}
type nom =
        |Nom1 
        |Nom2 of t0 
        |Nom3 of t1 * t2 *.... * tn 
	\end{lstlisting}
	le type récuresif :
	\begin{lstlisting}
type nom =
        |Nom1
        |Nom2 of nom
        |Nom3 of t1 * t2 *.... * tn
         \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Le fonctionnel}
  \framesubtitle{Le type paramétrés}
  le type paramétrés :
  \begin{lstlisting}
type nom =
         |Nom 1
         |Nom 2 of t0
         |Nom3 of ('a -> 'b)
  \end{lstlisting}
  \begin{lstlisting}
type nom = 
         |Nom 1 
         |Nom 2 of t0
         |Nom 3 of 'a 
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Le fonctionnel}
  \framesubtitle{Les exceptions}
  \begin{lstlisting}
exception Nom;;
exception Nom of int;;
  \end{lstlisting}
pour lever un exception : 
\begin{lstlisting}
raise ;;
- : exn -> 'a = <fun>
\end{lstlisting}
\begin{lstlisting}
try exp with 
|p1 -> exp1
|p2 -> exp2
.
.
.
|p3 -> exp3
\end{lstlisting}
\end{frame}
